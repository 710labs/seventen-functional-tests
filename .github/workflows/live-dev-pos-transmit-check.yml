name: Live - Dev - POS Transmit Check Last 10 Orders

on:
  workflow_dispatch:
  schedule:
    - cron: "0 10 * * *"
jobs:
  fetch-orders:
    name: Fetch Last 10 Orders
    runs-on: ubuntu-latest
    timeout-minutes: 5
    environment: live-dev
    outputs:
      order_ids_json: ${{ steps.collect.outputs.order_ids_json }}
    env:
      ALWAYS_ON_URL: ${{ secrets.ALWAYS_ON_URL_DEV }}
      LIVE_QA_AUTH: ${{ secrets.LIVE_DEV_QA_AUTH }}

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch orders and extract IDs
        id: collect
        run: |
          set -euo pipefail

          cat > fetch-orders.mjs <<'EOF'
          import fs from "node:fs/promises";

          const baseRaw = process.env.ALWAYS_ON_URL || "";
          const auth = process.env.LIVE_QA_AUTH || "";

          if (!baseRaw) {
            console.error("âŒ ALWAYS_ON_URL is not set.");
            process.exit(1);
          }
          if (!auth) {
            console.error("âŒ LIVE_QA_AUTH is not set.");
            process.exit(1);
          }

          const base = baseRaw.replace(/\/+$/, "");
          const ENDPOINT = `${base}/wp-content/plugins/persy/interface/qa/orders/?auth=${encodeURIComponent(auth)}`;

          console.log(`ðŸ” Fetching last 10 orders from ${base}`);

          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 20000);

          let res;
          try {
            res = await fetch(ENDPOINT, {
              headers: { "Accept": "application/json" },
              signal: controller.signal,
            });
          } catch (err) {
            console.error(`âŒ Request error: ${err.message}`);
            process.exit(1);
          } finally {
            clearTimeout(timeout);
          }

          if (!res.ok) {
            const body = await res.text().catch(() => "");
            console.error(`âŒ Non-OK HTTP status ${res.status}\n${body}`);
            process.exit(1);
          }

          const text = await res.text();
          let data;
          try { data = JSON.parse(text); }
          catch {
            console.error("âŒ Response was not valid JSON.");
            await fs.writeFile("orders-response.txt", text);
            process.exit(1);
          }

          await fs.writeFile("orders-response.json", JSON.stringify(data, null, 2));

          const orders = Array.isArray(data.orders) ? data.orders.slice(0, 10) : [];
          if (orders.length === 0) {
            console.error("âŒ No orders returned by API.");
            process.exit(1);
          }

          // Extract just the WooCommerce IDs
          const orderIds = orders.map(o => o.woocommerceId).filter(Boolean);

          console.log(`âœ… Found ${orderIds.length} orders:`);
          console.log(JSON.stringify(orderIds, null, 2));

          // Write to file for GitHub output
          await fs.writeFile("order-ids.json", JSON.stringify(orderIds));
          EOF

          node fetch-orders.mjs

          # Set GitHub output
          ORDER_IDS_JSON=$(cat order-ids.json)
          echo "order_ids_json=${ORDER_IDS_JSON}" >> "$GITHUB_OUTPUT"

          # Add to step summary
          ORDER_COUNT=$(echo "$ORDER_IDS_JSON" | jq '. | length')
          {
            echo "### Orders to Verify: ${ORDER_COUNT}"
            echo
            echo "\`${ORDER_IDS_JSON}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload API response
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: orders-response
          path: |
            orders-response.json
            orders-response.txt
            order-ids.json
          retention-days: 7

  verify-orders:
    name: Verify POS Fields
    needs: fetch-orders
    runs-on: ubuntu-latest
    if: ${{ always() && needs.fetch-orders.outputs.order_ids_json != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        order_id: ${{ fromJson(needs.fetch-orders.outputs.order_ids_json) }}
    env:
      ALWAYS_ON_URL: ${{ secrets.ALWAYS_ON_URL_DEV }}
      LIVE_QA_AUTH: ${{ secrets.LIVE_DEV_QA_AUTH }}

    steps:
      - name: Verify POS fields for order ${{ matrix.order_id }}
        env:
          ORDER_ID: ${{ matrix.order_id }}
        run: |
          set -euo pipefail

          # Ensure jq is present
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          BASE="${ALWAYS_ON_URL%/}"
          AUTH="${LIVE_QA_AUTH}"
          URL_REAL="${BASE}/wp-content/plugins/persy/interface/qa/orders/?auth=${AUTH}&id=${ORDER_ID}"
          URL_SAFE="${BASE}/wp-content/plugins/persy/interface/qa/orders/?auth=***&id=${ORDER_ID}"

          echo "ðŸ” Verifying POS fields for order ${ORDER_ID}"
          echo "âž¡ï¸  GET ${URL_SAFE}"

          if [[ -z "${AUTH}" ]]; then
            echo "âŒ LIVE_QA_AUTH is empty. Check your repo/org secret."
            exit 1
          fi

          attempts=6
          delay=10
          for i in $(seq 1 $attempts); do
            http_code=$(curl -sS -L -w "%{http_code}" -o /tmp/resp.json "$URL_REAL" || true)
            echo "â†©ï¸  HTTP $http_code (try $i/$attempts)"

            # Show outcome/message if JSON-ish
            if jq -e . >/dev/null 2>&1 </tmp/resp.json; then
              echo "ðŸ§© Outcome snapshot:"
              jq -r '{outcome, message}' /tmp/resp.json
            fi

            if [[ "$http_code" != "200" ]]; then
              sleep "$delay"; continue
            fi

            # Must be valid JSON
            if ! jq . >/dev/null 2>&1 </tmp/resp.json; then
              echo "âŒ Response is not valid JSON:"
              sed -n '1,200p' /tmp/resp.json
              sleep "$delay"; continue
            fi

            outcome=$(jq -r '.outcome // empty' /tmp/resp.json)
            if [[ "$outcome" != "success" ]]; then
              echo "â³ Outcome is '$outcome' â€” message: $(jq -r '.message // ""' /tmp/resp.json)"
              sleep "$delay"; continue
            fi

            # Check for required POS transmission fields
            instanceId=$(jq -r '.instanceId // .instanceID // empty' /tmp/resp.json)
            instanceName=$(jq -r '.instanceName // empty' /tmp/resp.json)
            instanceType=$(jq -r '.instanceType // empty' /tmp/resp.json)
            externalId=$(jq -r '.externalId // .externalID // empty' /tmp/resp.json)

            missing=()
            [[ -z "$instanceId"   ]] && missing+=("instanceId")
            [[ -z "$instanceName" ]] && missing+=("instanceName")
            [[ -z "$instanceType" ]] && missing+=("instanceType")
            [[ -z "$externalId"   ]] && missing+=("externalId")

            if (( ${#missing[@]} == 0 )); then
              echo "âœ… All required POS fields present for order ${ORDER_ID}:"
              jq -r '{instanceId, instanceName, instanceType, externalId}' /tmp/resp.json
              exit 0
            else
              echo "â³ Missing fields for order ${ORDER_ID}: ${missing[*]} â€” retrying in ${delay}sâ€¦"
              sleep "$delay"
            fi
          done

          echo "âŒ Verification failed for order ${ORDER_ID} after ${attempts} attempts."
          echo "ðŸ§¾ Last response body:"
          sed -n '1,200p' /tmp/resp.json
          exit 1

  notify-results:
    name: Notify POS Verification Results
    needs: [fetch-orders, verify-orders]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send Slack notification
        run: |
          # Get the total number of orders
          ORDER_IDS='${{ needs.fetch-orders.outputs.order_ids_json }}'
          TOTAL_ORDERS=$(echo "$ORDER_IDS" | jq '. | length')

          # Determine the verification job status
          VERIFY_RESULT="${{ needs.verify-orders.result }}"

          # Determine status and color
          if [ "$VERIFY_RESULT" == "success" ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="PASSED"
            COLOR="good"
            DETAILS="All $TOTAL_ORDERS orders have required POS transmission fields"
          elif [ "$VERIFY_RESULT" == "skipped" ]; then
            STATUS_EMOJI="â­ï¸"
            STATUS_TEXT="SKIPPED"
            COLOR="warning"
            DETAILS="No orders to verify"
          else
            STATUS_EMOJI="âŒ"
            STATUS_TEXT="FAILED"
            COLOR="danger"
            DETAILS="One or more orders missing required POS fields"
          fi

          # Build Slack message using jq
          jq -n \
            --arg color "$COLOR" \
            --arg status_emoji "$STATUS_EMOJI" \
            --arg status_text "$STATUS_TEXT" \
            --arg total_orders "$TOTAL_ORDERS" \
            --arg details "$DETAILS" \
            --arg workflow_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg event_name "${{ github.event_name }}" \
            '{
              "attachments": [
                {
                  "color": $color,
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": ($status_emoji + " Live - Dev - POS Transmission Check - " + $status_text)
                      }
                    },
                    {
                      "type": "section",
                      "fields": [
                        {
                          "type": "mrkdwn",
                          "text": "*Test:*\nPOS Transmission Field Verification"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Environment:*\nDev"
                        },
                        {
                          "type": "mrkdwn",
                          "text": ("*Orders Verified:*\n" + $total_orders)
                        },
                        {
                          "type": "mrkdwn",
                          "text": ("*Status:*\n" + $details)
                        }
                      ]
                    },
                    {
                      "type": "context",
                      "elements": [
                        {
                          "type": "mrkdwn",
                          "text": ("<" + $workflow_url + "|View workflow run> â€¢ Triggered: " + $event_name)
                        }
                      ]
                    }
                  ]
                }
              ]
            }' > /tmp/slack-payload.json

          # Send to Slack
          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d @/tmp/slack-payload.json
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
